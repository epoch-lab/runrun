# 技术方案设计 (V2 - 自动化任务调度)

## 1. 核心目标

构建一个可以后台长期运行的服务。该服务能自动管理所有用户的跑步任务，直到每个用户都达到预设的跑步总里程（如80km），然后自动停止该用户的任务。

## 2. 数据模型 (数据库设计)

我们将采用你提出的设计，并继续推荐使用 SQLite 作为数据库，因为它足够轻量且无需配置。

`users` 表结构如下：

-   `id` (INTEGER, 主键, 自增)
-   `account` (TEXT, 用户手机号)
-   `password` (TEXT, 用户密码)
-   `current_distance` (REAL, 当前已跑总距离, 默认为 0)
-   `target_distance` (REAL, 目标总距离, 默认为 80.0)
-   `is_running_required` (BOOLEAN, 是否需要继续跑步, 默认为 true)
-   `created_at` (DATETIME)
-   `updated_at` (DATETIME)

## 3. 系统架构与组件

整个系统将作为一个单独的 Go 程序长期在后台运行，主要包含以下几个核心组件：

-   主应用 (Main App):
    -   Go 程序的主入口。
    -   职责：启动时连接数据库、初始化并启动下面的“调度器”。

-   调度器 (Scheduler):
    -   我们将使用一个 Go 语言内置的定时任务库（例如 `gocron/cron`），让我们的程序自己管理自己的定时任务，而无需依赖操作系统的 `cron`。
    -   核心任务: “每日检查任务”，每天凌晨（例如 02:00）执行一次。

-   任务执行器 (Task Executor):
    -   这是“每日检查任务”的具体逻辑。当调度器在凌晨触发它时，它会：
        1.  查询数据库，获取所有 `is_running_required = true` 的用户列表。
        2.  遍历这个用户列表，为每一个用户单独安排一次当天的跑步任务。
        3.  安排方式：计算一个随机延迟时间，确保跑步任务发生在当天的“白天”（10:00 - 22:00）之内。例如，在凌晨2点为用户A计算出一个8.5小时的延迟，那么他就会在 10:30 被执行跑步。
        4.  使用 Go 语言的定时器 (`time.AfterFunc`) 来设置这个延迟执行。

-   跑步函数 (`runForUser`):
    -   这是被定时器延迟执行的核心函数，负责为单个用户完成一次跑步。
    -   流程:
        1.  从参数中获取该用户的账号密码。
        2.  调用 `protocol.Login()` 登录。
        3.  成功后，调用 `protocol.Submit()` 提交一次固定或随机的有效距离（例如 4-5km）。
        4.  提交成功后，更新数据库：将本次跑步距离累加到该用户的 `current_distance` 字段。
        5.  检查并更新状态：判断该用户的 `current_distance` 是否已大于或等于 `target_distance`。如果是，则将该用户的 `is_running_required` 字段更新为 `false`。

## 4. 工作流程

```
(每天 02:00)
     |
[调度器触发“每日检查”]
     |
[查询数据库: is_running_required=true]
     |
(得到用户列表 [A, B, C])
     |
(遍历用户) -> 为A计算随机延迟 -> 设置定时器(A)
           -> 为B计算随机延迟 -> 设置定时器(B)
           -> 为C计算随机延迟 -> 设置定时器(C)
     |
(时间到达 10:00-22:00 中的某个随机点)
     |
[定时器(A)触发，执行 runForUser(A)]
     |
     -> 1. Login
     -> 2. Submit
     -> 3. 更新数据库 current_distance
     -> 4. 检查是否达标 -> 是 -> 更新数据库 is_running_required = false
```