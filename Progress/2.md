# 技术方案设计 (V2 - 自动化任务调度)

## 1. 核心目标

构建一个可以后台长期运行的服务。该服务能自动管理所有用户的跑步任务，直到每个用户都达到预设的跑步总里程（如80km），然后自动停止该用户的任务。

## 2. 数据模型 (数据库设计)

我们将采用你提出的设计，并继续推荐使用 SQLite 作为数据库，因为它足够轻量且无需配置。

`users` 表结构如下：

-   `id` (INTEGER, 主键, 自增)
-   `account` (TEXT, 用户手机号)
-   `password` (TEXT, 用户密码)
-   `current_distance` (REAL, 当前已跑总距离, 默认为 0)
-   `target_distance` (REAL, 目标总距离, 默认为 80.0)
-   `is_running_required` (BOOLEAN, 是否需要继续跑步, 默认为 true)
-   `created_at` (DATETIME)
-   `updated_at` (DATETIME)

## 3. 系统架构与组件

整个系统将作为一个单独的 Go 程序长期在后台运行，主要包含以下几个核心组件：

-   主应用 (Main App):
    -   Go 程序的主入口。
    -   职责：启动时连接数据库、初始化并启动下面的“调度器”。

-   调度器 (Scheduler):
    -   我们将使用一个 Go 语言内置的定时任务库（例如 `gocron/cron`），让我们的程序自己管理自己的定时任务，而无需依赖操作系统的 `cron`。
    -   核心任务: “每日检查任务”，每天凌晨（例如 02:00）执行一次。

-   任务执行器 (Task Executor):
    -   这是“每日检查任务”的具体逻辑。当调度器在凌晨触发它时，它会：
        1.  查询数据库，获取所有 `is_running_required = true` 的用户列表。
        2.  遍历这个用户列表，为每一个用户单独安排一次当天的跑步任务。
        3.  安排方式：计算一个随机延迟时间，确保跑步任务发生在当天的“白天”（10:00 - 22:00）之内。例如，在凌晨2点为用户A计算出一个8.5小时的延迟，那么他就会在 10:30 被执行跑步。
        4.  使用 Go 语言的定时器 (`time.AfterFunc`) 来设置这个延迟执行。

-   跑步函数 (`runForUser`):
    -   这是被定时器延迟执行的核心函数，负责为单个用户完成一次跑步。
    -   流程:
        1.  从参数中获取该用户的账号密码。
        2.  调用 `protocol.Login()` 登录。
        3.  成功后，调用 `protocol.Submit()` 提交一次固定或随机的有效距离（例如 4-5km）。
        4.  提交成功后，更新数据库：将本次跑步距离累加到该用户的 `current_distance` 字段。
        5.  检查并更新状态：判断该用户的 `current_distance` 是否已大于或等于 `target_distance`。如果是，则将该用户的 `is_running_required` 字段更新为 `false`。

## 4. 工作流程

```
(每天 02:00)
     |
[调度器触发“每日检查”]
     |
[查询数据库: is_running_required=true]
     |
(得到用户列表 [A, B, C])
     |
(遍历用户) -> 为A计算随机延迟 -> 设置定时器(A)
           -> 为B计算随机延迟 -> 设置定时器(B)
           -> 为C计算随机延迟 -> 设置定时器(C)
     |
(时间到达 10:00-22:00 中的某个随机点)
     |
[定时器(A)触发，执行 runForUser(A)]
     |
     -> 1. Login
     -> 2. Submit
     -> 3. 更新数据库 current_distance
     -> 4. 检查是否达标 -> 是 -> 更新数据库 is_running_required = false
```

---

### 新增统一认证接口 (`/api/auth`)

#### 1. 接口概述

为了统一处理用户的注册和登录流程，我们新增一个多功能的认证接口。该接口通过用户提供的账号和密码，智能判断是应为新用户执行注册，还是对已有用户执行登录验证。

- 路径: `POST /api/auth`
- 请求体 (Request Body):
  ```json
  {
    "account": "user_account",
    "password": "user_password"
  }
  ```
- 响应体 (Response Body):
  ```json
  {
    "code": 0,
    "msg": "...",
    "data": null
  }
  ```

#### 2. 核心业务逻辑

服务器接收到请求后，将执行以下步骤：

1.  从请求体中解析 `account` 和 `password`。
2.  - 先调用一次Login，如果成功
        - 再查询数据库，检查 `account` 是否已存在。
            - 如果账号不存在:
                - 将 `account` 和加密后的 `password` 存入数据库。
                - 返回: `{ "code": 1, "msg": "登记成功" }`
            - 如果账号已存在:
                - 从数据库中获取该账号对应的加密密码。
                - 将用户传入的 `password` 与数据库中的密码进行比对。
                    - 如果密码匹配:
                        - 调用submit，立即执行一次跑步，
                        - 返回: `{ "code": 2, "msg": "已登记" }`
                    - 如果密码不匹配:
                        - 返回: `{ "code": 3, "msg": "账号或者密码错误" }`
    - 如果失败，`{ "code": 3, "msg": "账号或者密码错误" }`
    - 其他错误：`{ "code":5, "msg":"其他错误" }`

#### 3. 
